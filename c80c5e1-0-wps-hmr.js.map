{"version":3,"sources":["webpack:///./src/index.ts"],"names":["ParticleEmitter","gpu","maxParticles","this","spawnRate","particlesToSpawn","vertices","Float32Array","vertexBuffer","createBuffer","prototype","update","deltaTime","vertexData","contents","i","remainingLifetime","j","squatedLength","directionValue","Math","random","draw","ParticleRenderPass","app","vertexFunction","library","functionWithName","fragmentFunction","emitter","pipelineDescriptor","WebMetalRenderPipelineDescriptor","colorAttachments","pixelFormat","PixelFormatBGRA8Unorm","renderPipelineState","createRenderPipelineState","renderPassDescriptor","WebMetalRenderPassDescriptor","loadAction","LoadActionClear","storeAction","StoreActionStore","clearColor","render","commandBuffer","commandQueue","createCommandBuffer","drawable","nextDrawable","texture","commandEncoder","createRenderCommandEncoderWithDescriptor","setRenderPipelineState","setVertexBuffer","drawPrimitives","PrimitiveTypePoint","endEncoding","presentDrawable","commit","Application","canvas","lastTick","getContext","Error","createCommandQueue","createLibrary","document","getElementById","text","particleRenderPass","Date","now","setInterval","bind","requestAnimationFrame","window","onload"],"mappings":"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","file":"c80c5e1-0-wps-hmr.js","sourcesContent":["class ParticleEmitter {\n  vertexBuffer: any;\n  private spawnRate = 10000;\n  private particlesToSpawn = 0;\n\n  constructor(gpu: any, readonly maxParticles: number) {\n    const vertices = new Float32Array(8 * maxParticles);\n    this.vertexBuffer = gpu.createBuffer(vertices);\n  }\n\n  update(deltaTime: number) {\n    const vertexData = new Float32Array(this.vertexBuffer.contents);\n    this.particlesToSpawn += deltaTime * this.spawnRate;\n\n    for (let i = 0; i < this.maxParticles; ++i) {\n      const lifetime = vertexData[i * 8 + 3];\n      const remainingLifetime = lifetime - deltaTime;\n      if (remainingLifetime > 0) {\n        // Update position\n        for (let j = 0; j < 3; ++j) {\n          vertexData[i * 8 + j] += vertexData[i * 8 + 4 + j] * deltaTime;\n        }\n        // console.log(i);\n        // console.debug(\"Updated position = (\" + vertexData[i * 8 + 0] + \",\" + vertexData[i * 8 + 1] + \",\" + vertexData[i * 8 + 2] + \")\")\n\n        // Update lifetime\n        vertexData[i * 8 + 3] = remainingLifetime;\n      } else if (this.particlesToSpawn > 1) {\n        // Initialize position\n        for (let j = 0; j < 3; ++j) {\n          vertexData[i * 8 + j] = 0;\n        }\n        // Initialize speed\n        let squatedLength;\n        do {\n          squatedLength = 0;\n          for (let j = 0; j < 3; ++j) {\n            const directionValue = (Math.random() * 2 - 1);\n            vertexData[i * 8 + 4 + j] = directionValue * 0.2;\n            squatedLength += directionValue * directionValue;\n          }\n        } while (squatedLength > 1);\n\n        // Initialize lifetime\n        vertexData[i * 8 + 3] = 1 + Math.random();\n        --this.particlesToSpawn;\n\n        // console.debug(\"Spawned particle!\");\n        // console.debug(\"Speed = (\" + vertexData[i * 8 + 3 + 0] + \",\" + vertexData[i * 8 + 3 + 1] + \",\" + vertexData[i * 8 + 3 + 2] + \")\")\n      } else {\n        // console.debug(\"Particles to spawn: \" + this.particlesToSpawn);\n      }\n    }\n  }\n\n  draw() {\n\n  }\n}\n\nclass ParticleRenderPass {\n  private renderPipelineState: any;\n  private renderPassDescriptor: any;\n  private emitter: ParticleEmitter;\n\n  constructor(private app: Application) {\n    const vertexFunction = app.library.functionWithName(\"particle_vertex_main\");\n    const fragmentFunction = app.library.functionWithName(\"fragment_main\");\n\n    this.emitter = new ParticleEmitter(app.gpu, 1000);\n\n    const pipelineDescriptor = new WebMetalRenderPipelineDescriptor();\n    pipelineDescriptor.vertexFunction = vertexFunction;\n    pipelineDescriptor.fragmentFunction = fragmentFunction;\n    // NOTE: Our API proposal has these values as enums, not constant numbers.\n    // We haven't got around to implementing the enums yet.\n    pipelineDescriptor.colorAttachments[0].pixelFormat = app.gpu.PixelFormatBGRA8Unorm;\n\n    this.renderPipelineState = app.gpu.createRenderPipelineState(pipelineDescriptor);\n\n    this.renderPassDescriptor = new WebMetalRenderPassDescriptor();\n    // NOTE: Our API proposal has some of these values as enums, not constant numbers.\n    // We haven't got around to implementing the enums yet.\n    this.renderPassDescriptor.colorAttachments[0].loadAction = app.gpu.LoadActionClear;\n    this.renderPassDescriptor.colorAttachments[0].storeAction = app.gpu.StoreActionStore;\n    this.renderPassDescriptor.colorAttachments[0].clearColor = [0.35, 0.65, 0.85, 1.0];\n  }\n\n  update() {\n    this.emitter.update(33.33 / 1000);\n  }\n\n  render() {\n    const commandBuffer = this.app.commandQueue.createCommandBuffer();\n    const drawable = this.app.gpu.nextDrawable();\n    this.renderPassDescriptor.colorAttachments[0].texture = drawable.texture;\n\n    const commandEncoder = commandBuffer.createRenderCommandEncoderWithDescriptor(this.renderPassDescriptor);\n    commandEncoder.setRenderPipelineState(this.renderPipelineState);\n    commandEncoder.setVertexBuffer(this.emitter.vertexBuffer, 0, 0);\n\n    // NOTE: We didn't attach any buffers. We create the geometry in the vertex shader using\n    // the vertex ID.\n\n    // NOTE: Our API proposal uses the enum value \"triangle\" here. We haven't got around to implementing the enums yet.\n    commandEncoder.drawPrimitives(this.app.gpu.PrimitiveTypePoint, 0, this.emitter.maxParticles);\n\n    commandEncoder.endEncoding();\n    commandBuffer.presentDrawable(drawable);\n    commandBuffer.commit();\n  }\n}\n\nclass Application {\n  readonly gpu: any;\n  readonly commandQueue: any;\n  readonly library: any;\n  private lastTick = 0;\n  private particleRenderPass: ParticleRenderPass;\n\n  constructor(private canvas: HTMLCanvasElement) {\n    this.gpu = canvas.getContext(\"webgpu\");\n    if (!this.gpu) {\n      throw new Error(\"Failed to create webmetal context\");\n    }\n\n    this.commandQueue = this.gpu.createCommandQueue();\n    this.library = this.gpu.createLibrary((document.getElementById(\"library\") as HTMLScriptElement).text);\n\n    this.particleRenderPass = new ParticleRenderPass(this);\n\n    this.lastTick = Date.now();\n    setInterval(this.update.bind(this), 1000 / 30); // 30Hz\n    this.render();\n  }\n\n  update() {\n    const now = Date.now();\n    const delta = now - this.lastTick;\n    this.lastTick = now;\n\n    this.particleRenderPass.update();\n  }\n\n  render() {\n    this.particleRenderPass.render();\n\n    requestAnimationFrame(this.render.bind(this));\n  }\n}\n\nwindow.onload = () => {\n  const app = new Application(document.getElementById(\"canvas\") as HTMLCanvasElement);\n}"],"sourceRoot":""}